`Изолированность` же транзакции показывает то, насколько сильно влияют друг на друга параллельно выполняющиеся транзакции.

Стоит отметить, что самую высокую скорость выполнения и самую низкую согласованность имеет уровень `read uncommitted`.

Самую низкую скорость выполнения и самую высокую согласованность — `serializable`.

## Подготовка окружения

Для примеров была выбрана СУБД MySQL. PostgreSQL мог бы тоже использоваться, но он не поддерживает уровень изоляции `read uncommitted`, и использует вместо него уровень `read committed`. Да и как оказалось, разные СУБД по-разному воспринимают уровни изолированности. Могут иметь разнообразные нюансы в обеспечении изоляции, иметь дополнительные уровни или не иметь общеизвестных.


## Read uncommitted

Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций. Название уровня говорит само за себя — каждая транзакция видит незафиксированные изменения другой транзакции (феномен `грязного чтения`).

На данном уровне нельзя использовать данные, на основе которых делаются важные для приложения выводы и критические решения т.к выводы эти могут быть далеки от реальности.
Данный уровень можно использовать, например, для примерных расчетов чего-либо. Результат COUNT(*) или MAX(*) можно использовать в каких-нибудь нестрогих отчетах.
Другой пример это режим отладки. Когда во время транзакции, вы хотите видеть, что происходит с базой.

## READ COMMITTED

Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других транзакций. Таким образом, данный уровень обеспечивает защиту от `грязного чтения`.

Т2 видит все, что сделала Т1. Это так называемые феномен `неповторяющегося чтения`, когда мы видим обновленные и удаленные строки (UPDATE, DELETE), и феномен `чтения фантомов`, когда мы видим добавленные записи (INSERT).

## REPEATABLE READ


