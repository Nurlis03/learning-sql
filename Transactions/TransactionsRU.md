`Транзакция` — это набор операций по работе с базой данных (БД), объединенных в одну атомарную единицу.

Транзакционные базы данных (базы, работающие через транзакции) выполняют требования `ACID`, которые обеспечивают безопасность данных. В том числе финансовых данных =) Поэтому разработчики их и выбирают.

`Транзакция` — это архив для запросов к базе. Он защищает ваши данные благодаря принципу `«всё, или ничего»`.

Или выполнены все запросы, которые разработчик упаковал в одну транзакцию, или ни один.

Допустим, вы переводите все деньги с одной карточки на другую. Выглядит это `"внутри" `системы как несколько операций:

`delete from счет1 where счет = счет 1`

`insert into счет2 values ('сумма')`

Принцип `«всё или ничего»` тут очень помогает. Было бы обидно, если бы деньги со `счета1` списались, но на `счет2` не поступили... Потому что соединение оборвалось или вы в номере счета опечатались и система выдала ошибку...

Но благодаря объединению запросов в транзакцию при возникновении ошибки зачисления мы откатываем и операцию списания. Деньги снова вернулись на `счет 1`!

Если говорить по-научному, то `транзакция` — `упорядоченное множество операци`й, переводящих базу данных из одного согласованного состояния в другое. Согласованное состояние — это состояние, которое подходит под бизнес-логику системы.

## Как отправить транзакцию

Чтобы обратиться к базе данных, сначала надо открыть `соединение` с ней. Это называется `коннект` (от англ. `connection`, `соединение`). `Коннект` — это просто труба, по которой мы посылаем запросы.

Чтобы сгруппировать запросы в одну атомарную пачку, используем транзакцию. Транзакцию надо:

1. Открыть.
2. Выполнить все операции внутри.
3. Закрыть.

Как только мы закрыли транзакцию, труба освободилась. И ее можно переиспользовать, отправив следующую транзакцию.

Можно, конечно, каждый раз закрывать соединение с БД. И на каждое действие открывать новое. Но эффективнее переиспользовать текущие. Потому что создание нового коннекта — тяжелая операция, долгая.

При настройке приложения `администратор указывает, сколько максимально открытых соединений с базой может быть в один момент времени`. Это называется `пул соединений` — количество свободных труб.

`Разработчик` берет соединение из пула и отправляет по нему `транзакцию`. Как только `транзакция` закрывается (неважно, успешно она прошла или откатилась), соединение возвращается в `пул`, и его может использовать следующая бизнес-операция.

## Как открыть транзакцию

Зависит от базы данных. В `Oracle` транзакция открывается сама, по факту первой изменяющей операции. А в `MySql` надо явно писать `«start transaction»`.

## Как закрыть транзакцию

Тут есть `2` варианта:

1. `COMMIT` — подтверждаем все внесенные изменения;
2. `ROLLBACK` — откатываем их;

И вся фишка транзакционной базы в том, что база сначала применяет запрос `«виртуально»`, реально ничего в базе не изменив. Ты можешь посмотреть, как запрос изменит базу, ничего при этом не сохраняя.

Например, я пишу запрос:


```SQL
insert into clients (name, surname) values ('Иван', 'Иванов');
-- добавь в таблицу клиентов запись с именем «Иван» и фамилиев «Иванов»
```

Запрос выполнен успешно, хорошо! Теперь, если я сделаю select из этой таблицы, прям тут же, под своим запросом — он находит Иванова! Я могу увидеть результат своего запроса.

Но! Если открыть графический интерфейс программы, никакого Иванова мы там не найдем. И даже если мы откроем новую вкладку в sql developer (или в другой программе, через которую вы подключаетесь к базе) и повторим там свой select — Иванова не будет.

А все потому, что я не сделала коммит, не применила изменения:

```SQL
INSERT INTO clients(name, surname) values('Иван', 'Иванов');
COMMIT;
```

Я могу добавить кучу данных. Удалить полтаблицы. Изменить миллион строк. Но если я закрою вкладку sql developer, не сделав коммит, все эти изменения потеряются.

## Итого


Транзакция — набор операций по работе с базой данных, объединенных в одну атомарную пачку.

Одной операции всегда соответствует одна транзакция, но в рамках одной транзакции можно совершить несколько операций (например, несколько разных insert можно сделать, или изменить и удалить данные...).

Делая комит, мы заканчиваем одну бизнес-операцию, и возвращаем коннект в пул без открытой транзакции. То есть просто освобождаем трубу для других. Следующая бизнес-операция берет эту трубу и фигачит в нее свои операции. Поэтому важно сделать rollback, если изменения сохранять не надо. Не откатите и вернете соединение в пул? Его возьмет кто-то другой и сделает коммит. Своих изменений, и ваших, неоткаченных.

Не путайте соединение с базой (коннект) и саму транзакцию. Коннект — это просто труба, операции (update, delete…) мы посылаем по трубе, старт транзакции и commit /rollback — это группировка операций в одну атомарную пачку.